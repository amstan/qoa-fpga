#!/usr/bin/env python3
"""
Library that allows any python to simply "import" a verilog module.

What happens in the background:
* Heavy user of verilator
* verilator generates build/Vmodule.h with the raw verilog module's ports
    * Unfortunatelly this is a C++ file that's hard to use from python
* Regex those ports to decode their names and types
* Generate a wrapper full of getters, setters and the eval function and
  put the wrappers inside an `extern "C"`
* Compile wrapper and all the other verilator libraries into build/module.so
* Together with some remembered prototype cdefs from the generated wrapper,
  load **module.so** using python's cffi.
* Pythonize the resulting c functions into a class, every port is a python
  property that calls the setters and getters in the background

Example:
>> import pyrilator
>> YourClass = pyrilator.pyrilate("yourmodule.sv")
# ^^^ this does the verilog compiling, takes a couple of sec
>> instance = YourClass()
>> instance.clk = 1
>> instance.eval()
>> print(instance.output)
"""

import cffi
from pathlib import Path
import pprint
import re
import subprocess

VFLAGS = [ # TODO: add this to pyrilate arguments
    # "-Wall", # TODO: fix lms.sv so it doesn't need it
    "-Wno-WIDTH", # These are inane, something as simple as (var == 25) ? : will warn with this on
]
VERILATOR_SOURCES = [
    "/usr/share/verilator/include/verilated.cpp",
    "/usr/share/verilator/include/verilated_threads.cpp",
]

C_TEMPLATE = """// Automatically generated by pyrilator
#include "string.h"
#include "verilated.h"
#include "V{sv_module}.h"

extern "C" {{
H_CONTENTS

void *{sv_module}_new(int argc, char **argv) {{ //def
	Verilated::commandArgs(argc, argv);
	return (void *)new V{sv_module};
}}

void {sv_module}_eval(void *tb) {{ //def
	((V{sv_module} *)tb)->eval();
}}

{arg_function_contents}

}}
"""

GETTER_TEMPLATE = """{type}{ret_pointer} {sv_module}_get_{arg_name}(void *tb) {{ //def
	return ((V{sv_module} *)tb)->{arg_name};
}}
"""

SETTER_TEMPLATE = """void {sv_module}_set_{arg_name}(void *tb, {type} v{array_size}) {{ //def
	memcpy({memcpy_ref}(((V{sv_module} *)tb)->{arg_name}), {memcpy_ref}v, sizeof({type} {array_size}));
}}
"""

# See verilated_types.h
SIZE_MAPPING = {
    "8": "unsigned char",
    "16": "unsigned short int",
    "": "unsigned int",
    "64": "unsigned long long int",
}

ARGUMENT_RE = re.compile(r"""
    VL_(?P<dir>IN|OUT)(?P<size>[0-9]*)
        \(
            (?:
                 &(?P<var>\w+) |
                \(&(?P<array>\w+)\)\[(?P<array_size>[0-9]+)\]
            ),
            (?P<msb>[0-9]+),
            (?P<lsb>[0-9]+)
        \);
    """, re.VERBOSE)

def compile(sv_file:Path, build_dir):
    sv_module = sv_file.stem
    build_dir = Path(build_dir).resolve()

    subprocess.check_call([
        "verilator",
        *VFLAGS,
        "-cc", sv_file,
        "--Mdir", str(build_dir),
        "--build",
        "-CFLAGS", "-fPIC",
    ])

    verilated_header_contents = (build_dir/f"V{sv_module}.h").read_text()
    arg_functions = []
    args = {}
    for argument in ARGUMENT_RE.finditer(verilated_header_contents):
        a = argument.groupdict()

        if a["var"] is not None:
            arg_name = a["var"]
            array_size = ""
            ret_pointer = ""
            memcpy_ref = "&"
        elif a["array"] is not None:
            arg_name = a["array"]
            array_size = "[" + a["array_size"] + "]"
            ret_pointer = "*"
            memcpy_ref = ""

        template = GETTER_TEMPLATE
        if "IN" in a["dir"]:
            template += SETTER_TEMPLATE

        f = template.format(
            type = SIZE_MAPPING[a['size']],
            **locals()
        )
        arg_functions.append(f)
        args[arg_name] = a

    arg_function_contents='\n'.join(arg_functions)
    c_contents = C_TEMPLATE.format(**locals())

    arg_prototypes = []
    for line in c_contents.split("\n"):
        if line.endswith("//def"):
            arg_prototypes.append(
                line.removesuffix(" { //def")
                + ";"
            )
    h_contents = '\n'.join(arg_prototypes)
    c_contents = c_contents.replace("H_CONTENTS", h_contents)

    cpp_file = build_dir/f"{sv_module}.pyrilated.cpp"
    with open(cpp_file, "w") as f:
        f.write(c_contents)

    h_file = build_dir/f"{sv_module}.pyrilated.h"
    with open(h_file, "w") as f:
        f.write(h_contents)

    with open((build_dir/f"{sv_module}.h"), "w") as f:
        f.write(h_contents)

    so_file = build_dir/f"{sv_module}.so"

    # TODO: cache this somehow, ala how a makefile does it
    subprocess.check_call([
        "g++",
        "-fPIC",
        "-I", "/usr/share/verilator/include",
        "-I", str(build_dir),
        *VERILATOR_SOURCES,
        "-Wall",
        str(cpp_file),
        str(build_dir/f"V{sv_module}__ALL.a"),

        "--shared",
        "-o", str(so_file),
    ])

    return h_file, so_file, args

def pyrilate(sv_file:Path, build_dir):
    class Pyrilated_:
        _sv_module = sv_file.stem

        _h_file, _so_file, _args = compile(sv_file, build_dir)

        _ffi = cffi.FFI()
        _ffi.cdef(_h_file.read_text())

        _lib = _ffi.dlopen(str(_so_file))

        def __init__(self):
            self._tb = getattr(self._lib, self._sv_module+"_new")(0, [])

            eval_f = getattr(self._lib, self._sv_module+"_eval")
            self.eval = lambda: eval_f(self._tb)

            def create_property(arg_name, array_size=None):
                getter = getattr(self._lib, self._sv_module+"_get_"+arg_name)
                if not array_size:
                    fget=lambda self: getter(self._tb)
                else: # is_array
                    array_size = int(array_size)
                    fget=lambda self: list(getter(self._tb)[0:array_size])
                try:
                    setter = getattr(self._lib, self._sv_module+"_set_"+arg_name)
                    fset = lambda self, v: setter(self._tb, v)
                except AttributeError:
                    fset = None
                return property(fget, fset)

            for arg_name, arg in self._args.items():
                setattr(Pyrilated_, arg_name, create_property(arg_name, arg["array_size"]))

    Pyrilated_.__name__ += Pyrilated_._sv_module
    Pyrilated_.__qualname__ += Pyrilated_._sv_module
    return Pyrilated_

"""These are annoyingly required, see
https://veripool.org/guide/latest/faq.html#how-do-i-access-signals-in-c

> Note that even signed ports are declared as unsigned;
> you must sign extend yourself to the appropriate signal width.
"""
def cast_to_unsigned(x, bytes):
    return int.from_bytes(int(x).to_bytes(bytes, signed=True))
def cast_to_signed(x, bytes):
    return int.from_bytes(int(x).to_bytes(bytes), signed=True)

MAX_INT32 = (1<<32)-1

if __name__=="__main__":
    BUILD_DIR = Path(__file__)/"../../build/"
    p = pyrilate((Path(__file__)/"../../verilog/lms.sv").resolve(), build_dir=BUILD_DIR)
